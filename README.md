[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/Z6NE2ogx)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=16548232&assignment_repo_type=AssignmentRepo)
# Práctica 1: Introducción al desarrollo. Reflexiones.

Apoyate en los siguientes recursos para realizar la práctica:

[Descripción de la práctica](https://revilofe.github.io/section3/u01/practica/EDES-U1.-Practica010/)


---

# Título de la Actividad

## Identificación de la Actividad
- **ID de la Actividad:** 2425-u1-1-1-reflexiones-Maiio268
- **Módulo:** EDES
- **Unidad de Trabajo:** Unidad 1: Introducción al desarrollo del software
- **Fecha de Creación:** [Fecha de creación]
- **Fecha de Entrega:** 20/10/2024
- **Alumno(s):** 
  - **Nombre y Apellidos:** Mario Montes Bermúdez
  - **Correo electrónico:** mmonber326@g.educaand.es
  - **Iniciales del Alumno/Grupo:** MMB

## Descripción de la Actividad
La actividad consiste en responder a las preguntas propuestas por el profesor sobre la Unidad 1: Introducción al desarrollo del software.

## Instrucciones de Compilación y Ejecución
1. **Requisitos Previos:**
   - [Lenguaje de programación y versión]
   - [Entorno de desarrollo o dependencias necesarias]

2. **Pasos para Compilar el Código:**
   ```bash
   [Comando para compilar el código]
   ```

3. **Pasos para Ejecutar el Código:**
   ```bash
   [Comando para ejecutar la aplicación]
   ```

4. **Ejecución de Pruebas:**
   ```bash
   [Comandos para ejecutar pruebas, si las hubiera]
   ```

## Desarrollo de la Actividad
### Descripción del Desarrollo
He desarrollado la actividad respondiendo a las perguntas propuestas e informándome sobre las respuestas leyendo los apuntes adjuntados por el profesor y consultando ciertas páginas web.mas.

### Código Fuente
[Aquí se incluirá un enlace directo a los archivos de código fuente en el repositorio, por ejemplo, si se está usando GitHub: `src/main.java` o algún enlace directo.]

### Ejemplos de Ejecución
- **Entrada 1:** Descripción de la entrada y valor de prueba.
- **Salida Esperada 1:** Explicación de la salida esperada y el resultado de la prueba.

### Resultados de Pruebas
[Aquí se detallará cómo se ha verificado la funcionalidad del código, incluyendo resultados de pruebas automatizadas o manuales, en caso de que las haya.]

## Documentación Adicional
- **Manual de Usuario:** [Enlace a la documentación del usuario, si existe]
- **Autorización de Permisos:** Verificar que el profesor tenga permisos de lectura en el repositorio para revisar el código.

## Conclusiones
Tras desarrollar la actividad, he aprendido sobre el software y hardware en general, los diferentes tipos de lenguaje y sus usos y los diversos tipos de herramientas para el desarrollo del software.

## Referencias y Fuentes
He usado chat gpt para informarme sobre ciertas dudas que tenía sobre algunas preguntas.

### Notas Adicionales:
1. **Nombres de Archivos y Repositorios:**
   - Asegúrate de que el nombre del archivo o repositorio siga la estructura definida: `XXX-idActividad-Iniciales`.
2. **Permisos:**
   - Verifica que el profesor tenga los permisos necesarios para acceder al repositorio o documento.
3. **Formato:**
   - Si se entrega en formato PDF o Google Docs, asegúrate de cumplir con el mínimo y máximo de folios establecidos.
4. **Compilación y Ejecución:**
   - Detalla claramente cómo compilar y ejecutar el código, incluyendo las instrucciones en el archivo `README.md`.

ACTIVIDAD:
P 1.10: Reflexión y discusión sobre los resultados¶
1. Relación software y hardware¶
1.1. Primera parte¶
1.1.1. ¿Cómo se ejecuta el código en el procesador?
1.1.2. ¿Qué hace la memoria RAM con la información del botón o el LED?
1.1.3. ¿Cómo se comunican los periféricos (botón y LED) con el procesador?

1.2. Segunda parte¶
1.2.1. ¿Cómo interactúan el procesador, la memoria y los periféricos en la ejecución del programa?
1.2.2. ¿Qué pasa con los datos en la memoria cuando el programa se ejecuta?
1.2.3. ¿Qué roles juegan las instrucciones del software en esta interacción?
1.2.4. ¿Cómo se relaciona esta simulación con lo que ocurre en un ordenador real?

2. Del código fuente al ejecutable¶
2.1. ¿Cómo se diferencia el código fuente del código objeto y del ejecutable?
2.2. ¿Por qué el ordenador no puede entender el código fuente directamente?
2.3. ¿Por qué es importante el paso de enlazado en la creación de programas?
2.4. ¿Qué ocurre si falta alguna de las etapas (código objeto o ejecutable)?

3. Generación de código intermedio¶
3.1. ¿Cómo difiere el código intermedio del código ejecutable tradicional?
3.2. ¿Por qué es útil tener una máquina virtual?
3.3. ¿Qué ventajas ofrece el código intermedio?
3.4. ¿Además de java, qué otros lenguajes usan máquinas virtuales?

4. Lenguajes de programación¶
4.1. Primera parte¶
Compara el proceso de ejecución entre el lenguaje compilado y el interpretado.
4.1.1. ¿Qué diferencias notaron en el proceso de compilación frente a la ejecución directa?
4.1.2. ¿Qué pasa si hay un error de sintaxis en cada lenguaje? ¿Cuándo se detecta el error?

4.2. Segunda parte¶
Compara un lenguaje de alto nivel con uno de bajo nivel.
4.2.1. ¿Qué notaron sobre la abstracción entre los lenguajes de alto nivel y bajo nivel?
4.2.2. ¿Qué ventajas y desventajas encontraron en cada uno?

4.3. Tercera parte¶
Compara un lenguaje orientado a objetos vs funcional.
4.3.1. ¿Cómo funciona la organización de datos en Java usando objetos y métodos?
4.3.2. ¿Cómo es diferente trabajar en un enfoque funcional en Python, usando solo funciones puras?

4.4. Reflexión final¶
4.4.1. ¿Qué lenguajes se sintieron más fáciles de usar? ¿Por qué?
4.4.2. ¿En qué casos es preferible usar un lenguaje compilado frente a uno interpretado?
4.4.3. ¿Cuándo es mejor usar un lenguaje de alto nivel en lugar de uno de bajo nivel?
4.4.4. ¿Cómo se siente trabajar con el paradigma orientado a objetos en comparación con el imperativo o funcional?

5. Herramientas de desarrollo¶
5.1. Primera parte¶
Respecto a las proceso de creación de software identifica un conjunto de herramientas a usar.
5.1.1. ¿Qué hace cada una de las herramientas?
5.1.2. ¿Qué tipo de tareas facilita?
5.1.3. ¿Qué características ofrece que la hacen única o diferente de otras herramientas similares?
5.1.4. Elige una ¿Cómo es la experiencia de usuario al usarla? ¿Es fácil o compleja?
5.1.5. Elige una ¿En qué situaciones sería ideal utilizar esta herramienta?
5.1.6. Elige una ¿Qué limitaciones encontraste en la herramienta?

5.2. Segunda parte¶
Céntrate en una herramienta dentro de la misma categoría y compárala con otras:
5.2.1. ¿Qué herramienta se considera más útil y por qué?
5.2.2. ¿Qué ventajas tiene una sobre la otra?
5.2.3. ¿Cuál herramienta resultó ser la más intuitiva y por qué?
5.2.4. ¿En qué casos se recomendaría usar un compilador en lugar de un intérprete?
5.2.5. ¿Qué tipo de proyectos se beneficiarían más de un framework como Django?

5.3. Reflexión final¶
Con base en la experiencia de evaluación de las herramientas:
5.3.1. ¿Cómo crees que impacta la elección de la herramienta en la calidad del software?
5.3.2. ¿Qué características buscarías en una herramienta para facilitar tu flujo de trabajo?
5.3.3. ¿Cómo cambió tu percepción de estas herramientas después de haberlas probado y evaluado?


RESPUESTAS:
1. Relación software y hardware
1.1. Primera parte
1.1.1. El código es procesado por la CPU, que hace los cálculos necesarios para que el programa funcione. Se pueden distinguir tres fases: Captación (la CPU recibe las instrucciones), decodificación (la CPU interpreta las instrucciones recibidas) y ejecución (la CPU ejecuta las instrucciones ya interpretadas).
1.1.2. La información del botón o el LED se guarda temporalmente en la memoria RAM mientras se esté ejecutando el programa, cuando se apague el equipo, esta información desaparecerá.
1.1.3. El botón es un dispositivo de entrada y el LED es un dispositivo de salida, la CPU procesa el código recibido por el botón y la información sale finalmente por los dispositivos de salida, es decir, el LED se enciende cuando le damos al botón gracias al código procesado por la CPU.
1.2. Segunda parte
1.2.1. El software envía instrucciones a los periféricos (teclado, disco duro...), depende el periférico puede ser de entrada o salida, después el programa se carga en la memoria RAM y la CPU va recuperando una a una las instrucciones y las va ejecutando, llevando a cabo las tareas que el software tenia programadas. 
1.2.2. Cada vez que ejecutamos un programa en el ordenador, este se carga en la memoria RAM, la cual guarda temporalmente los datos mientras se ejecuta el programa. Pongamos de ejemplo el juego del tetris, la memoria RAM almacena temporalmente la posición de las piezas mientras el juego sigue en ejecución.
1.2.3. El software es el que da las instrucciones (el código) sobre algo, el procesador es el que ejecuta esas instrucciones, es decir, esas instrucciones son las que dictan qué hacer, son las que mandan.
1.2.4. Pongamos el ejemplo de un videojuego cualquiera: cuando se presiona una tecla, el teclado envía una señal al procesador y éste ejecuta la órden mientras, la RAM guarda temporalmente los datos, y el disco duro se encargaría de almacenar la partida por si quieres continuarla en otro momento.

2. Del código fuente al ejecutable
2.1. El código fuente son las instrucciones que se escriben con un lenguaje de programación (Python, Java, C...) que solo entendemos los humanos pero las máquinas no. El código objeto es el código fuente compilado, es decir, transformado de forma que la máquina esté más cerca de entender el código, aunque todavía no es ejecutable. Finalmente, el código ejecutable es la versión final que puede ser leída y ejecutada por la máquina, ya que está escrito en lenguaje máquina (unos y ceros).
2.2. El ordenador no puede entender el código fuente directamente porque está escrito a partir de lenguajes de programación los cuales sólo nosotros los humanos podemos entender, el ordenador sólo entiende el lenguaje máquina (unos y ceros).
2.3. El enlazador hace que el programa funcione correctamente ya que en él se incluyen las bibliotecas necesarias, además, esta herramienta une los archivos del código objeto en un solo archivo ejecutable.
2.4. Si falta el código ejecutable no puede ejecutarse el programa ya que la máquina no entiende el código objeto y si falta el código objeto tampoco podría ejecutarse el programa porque no podría crearse el ejecutable debido a que no existiría el proceso de enlazado.

3. Generación de código intermedio
3.1. El código intermedio no está preparado para ser ejecutado, su arquitectura suele ser independiente del sistema operativo y la del procesador, mientras que el código ejecutable tradicional sí puede ejecutarse directamente y su código es específico de la arquitectura de la máquina.
3.2. La máquina virtual se encarga de ejecutar el código intermedio, traduciendo el código a instrucciones que puedan ser procesadas por la CPU, es decir, es útil porque es el "intérprete" entre el código intermedio y el hardware.
3.3. Ofrece varias ventajas: portabilidad (con las máquinas virtuales adecuadas, el mismo código puede funcionar en varios sistemas operativos distintos sin tener que recompilarlo de nuevo), seguridad (las máquinas virtuales controlan el acceso del código intermedio al hardware, defendiendo al equipo de programas maliciosos) y optimización en tiempo de ejecución (algunas máquinas virtuales utilizan técnicas como la compilación Just-In-Time (JIT), que convierte el código intermedio en código de máquina justo antes de que sea ejecutado, optimizando el rendimiento del programa).
3.4. También usan máquinas virtuales programas como C#, Ruby, PHP, Erlang, Kotlin, Scala, Haskell...

4. Lenguajes de programación
4.1. Primera parte
4.1.1. En la compilación, el código fuente se transforma a código objeto, mientras que en la ejecución directa el código fuente se traduce y ejecuta línea por línea.
4.1.2. Si hay un error de sintaxis en el lenguaje compilado, éste se detecta antes de transformar el código fuente a código objeto, pero en el lenguaje interpretado el error se detecta cuando se traduce y ejecuta línea por línea el código fuente.
4.2. Segunda parte
4.2.1. La abstracción de los lenguajes de alto nivel es más alta ya que no se enfoca directamente en el hardware, sino en el estado del programa y cómo este cambia, mientras que la abstracción de los lenguajes de bajo nivel es menor debido a que proporcionan un controlo directo sobre el hardware.
4.2.2. Los lenguajes de alto nivel son muy fáciles de escribir y comprender, sin embargo, tienen menos control sobre los detalles de bajo nivel del hardware, mientras que los lenguajes de bajo nivel ofrecen mucho control y eficiencia pero son más difíciles de aprender y escribir y se usan cuando se necesita acceso directo a los recursos del sistema o alto rendimiento.
4.3. Tercera parte
4.3.1. Los objetos encapsulan datos y comportamientos, este tipo de lenguaje es útil cuando se desea modelar elementos del mundo real dentro del software.
4.3.2. Este enfoque funcional es diferente al tradicional enfoque imperativo de Python, aquí se definen funciones y la programación se presenta de una forma más estructurada.
4.4. Reflexión final
4.4.1. Los interpretados, ya que son más flexibles y fáciles de probar porque no necesitan ser compilados.
4.4.2. Por ejemplo, cuando se requiere un tiempo de ejecución más rápido, ya que en el lenguaje compilado el código ya ha sido traducido a instrucciones máquina.
4.4.3. Cuando se requiere alto rendimiento o acceso directo a los recursos del sistema es mejor usar uno de bajo nivel, mientras que cuando se pretende la gestión de la memoria automática, es mejor usar un lenguaje de alto nivel.
4.4.4. El paradigma orientado a objetos se enfoca en organizar el código en torno a objetos que contienen datos encapsulados, mientras que el imperativo se basa en instrucciones y el funcional en funciones puras.

5. Herramientas de desarrollo

5.1. Primera parte
5.1.1. Los editores incorporan funcionalidades, como el coloreado de la sintaxis, que ayudan al programador, el compilador traduce el código fuente a código máquina, el intérprete ejecuta el código fuente línea por línea, sin necesidad de compilarlo previamente a código máquina, las herramientas de documentación mantienen la claridad del código y facilitan su comprensión, los depuradores analizan el comportamiento de un programa en tiempo de ejecución para detectar errores, los sistemas de Gestión de Versiones controlan los cambios en el código y permiten la colaboración en equipo, los fameworks proporcionan una estructura predefinida para desarrollar aplicaciones y las herramientas de pruebas aseguran que el software funcione como se espera.
5.1.2. Los editores se suelen usar para edición rápida de código fuente, scripts o archivos de configuración, los compiladores se usan cuando se necesita generar programas con alto rendimiento, los intérpretes se usan principalmente para prototipado rápido y scripts de automatización, las herramientas de documentación se usan para crear guías de uso, referencias de API y documentación técnica de los proyectos, los depuradores se utilizan para identificar y corregir errores lógicos o de ejecución en programas que no producen el resultado esperado, los sistemas de Gestión de Versiones facilitan la colaboración en equipo, permiten gestionar diferentes versiones del código y garantizan la trazabilidad de los cambios, los frameworks se usan para acelerar el desarrollo de proyectos y las herramientas de prueba se utilizan para verificar que el software cumple con los requisitos funcionales y no presenta errores.
5.1.3. Editores de Texto: Consumen pocos recursos, lo que los hace útiles en sistemas con poca capacidad de procesamiento y pueden ser utilizados en sistemas donde no es práctico instalar un IDE completo. Compiladores: Generan código ejecutable de alto rendimiento y ofrecen más control sobre la optimización del código. Intérpretes: Permiten ejecutar código de manera interactiva y no requieren un proceso de compilación, lo que facilita la edición y ejecución inmediata del código. Herramientas de Documentación: Automatizan la creación de documentación, reduciendo el esfuerzo manual y aseguran que la documentación se mantenga actualizada con el código. Depuradores: Facilitan la identificación de errores complejos y permiten explorar el estado del programa en tiempo real. Sistemas de Gestión de Versiones: Permiten trabajar en equipo de manera eficiente y segura y facilitan el seguimiento y revertido de cambios. Frameworks: Ahorran tiempo en el desarrollo al reutilizar componentes y estandarizan la estructura y organización del código. Herramientas de pruebas: Detectan errores y malas prácticas antes de que lleguen al entorno de producción y mejoran la mantenibilidad y legibilidad del código.
5.1.4. Compilador: La experiencia es fácil ya que es una herramienta que básicamente no tiene complicación, lo único que hace es traducir el código fuente a código máquina, no tiene más.
5.1.5. Compilador: Cuando se necesite generar un programa con alto rendimiento que aproveche al máximo los recursos del hardware y sea ejecutable directamente sin necesidad de intérpretes. 
5.1.6. Intérprete: al ejecutar el código línea por línea, el proceso suele ser más lento que el de un código compilado.
5.2. Segunda parte
5.2.1. Para mi. el compilador es la herramienta más útil, ya que sin ésta sería imposible ejecutar los códigos escritos en lenguajes como C o C++.
5.2.2. El compilador tiene un proceso más rápido que el intérprete y estos se usan cuando se necesita generar programas con alto rendimiento, que aprovechen al máximo los recursos del hardware y sean ejecutables directamente sin necesidad de intérpretes.
5.2.3. Los sistemas de Gestión de Versiones, es la herramienta más intuitiva ya que tiene comandos muy simples (por ejemplo Git: git add, git commit -m, git push...) y tiene facilidad de uso.
5.2.4. Cuando se necesite generar un programa con alto rendimiento que aproveche al máximo los recursos del hardware y sea ejecutable directamente sin necesidad de intérpretes. 
5.2.5. El desarrollo de aplicaciones web en Python se beneficiarían más de Django.
5.3. Reflexión final
5.3.1. Impacta bastante, por ejemplo, la elección de frameworks como Django proporcionan una estructura predefinida para desarrollar aplicaciones, lo que hace que la calidad del software aumente considerablemente, también el uso de, por ejemplo, las herramientas de documentación, que mantienen la claridad del código y facilitan su comprensión.  ¿Cómo crees que impacta la elección de la herramienta en la calidad del software?
5.3.2. Buscaría una herramienta intuitiva y fácil de utilizar, que sea rápida y eficiente, que funcione bien con el resto de herramientas implementadas anteriormente por el usuario y que la herramienta ofrezca una buena seguridad.
5.3.3. Antes no sabía mucho sobre ciertas herramientas, ni cómo funcionaban ni cómo se aplicaban, pero ahora que las he evaluado tengo una mejor idea de cómo y para qué se utilizan.


